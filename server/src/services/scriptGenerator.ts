import { Database } from 'better-sqlite3';

export interface ScriptConfig {
  spreadsheetId: string;
  backendUrl: string;
  accountId: string;
}

/**
 * Generate the master Google Ads data collection script
 * This script collects ALL data and syncs it to backend
 * Does NOT apply any changes - just pure data collection
 */
export function generateMasterScript(config: ScriptConfig): string {
  return `/**
 * Google Ads Master Data Collection Script
 * Generated by: Google Ads Builder
 *
 * This script collects ALL data from your Google Ads account and syncs it
 * to your backend for analysis and automation. It does NOT make any changes
 * automatically - your automation rules control what gets applied.
 *
 * Schedule: Run HOURLY for best results
 */

var CONFIG = {
  backendUrl: '${config.backendUrl}',
  spreadsheetId: '${config.spreadsheetId}',
  accountId: '${config.accountId}'
};

function main() {
  var startTime = new Date();
  Logger.log('üöÄ Starting Master Data Collection Script...');
  Logger.log('Account: ' + AdsApp.currentAccount().getName());

  try {
    // 1. Collect all data
    var data = collectAllData();

    // 2. Sync to Google Sheets
    if (CONFIG.spreadsheetId) {
      syncToSheets(data);
      Logger.log('‚úì Synced to Google Sheets');
    }

    // 3. Send to backend API
    sendToBackend(data);
    Logger.log('‚úì Sent to backend');

    var duration = (new Date() - startTime) / 1000;
    Logger.log('‚úÖ Data collection complete in ' + duration + 's');

  } catch (e) {
    Logger.log('‚ùå Error: ' + e.message);
    Logger.log(e.stack);

    // Send error to backend
    sendError(e);
  }
}

/**
 * Collect all data from Google Ads account
 */
function collectAllData() {
  var data = {
    timestamp: new Date().toISOString(),
    accountId: CONFIG.accountId,
    accountName: AdsApp.currentAccount().getName(),
    campaigns: [],
    adGroups: [],
    keywords: [],
    ads: [],
    searchTerms: [],
    performance: {},
    summary: {}
  };

  var campaignIterator = AdsApp.campaigns()
    .withCondition('Status IN [ENABLED, PAUSED]')
    .get();

  var campaignCount = 0;
  var adGroupCount = 0;
  var keywordCount = 0;
  var adCount = 0;

  while (campaignIterator.hasNext()) {
    var campaign = campaignIterator.next();
    campaignCount++;

    // Campaign data
    var stats = campaign.getStatsFor('LAST_30_DAYS');
    var campaignData = {
      id: campaign.getId().toString(),
      name: campaign.getName(),
      status: campaign.isEnabled() ? 'active' : 'paused',
      budget: campaign.getBudget() ? campaign.getBudget().getAmount() : 0,
      impressions: stats.getImpressions(),
      clicks: stats.getClicks(),
      cost: stats.getCost(),
      conversions: stats.getConversions(),
      ctr: stats.getCtr(),
      averageCpc: stats.getAverageCpc()
    };
    data.campaigns.push(campaignData);

    // Ad Groups
    var adGroupIterator = campaign.adGroups()
      .withCondition('Status IN [ENABLED, PAUSED]')
      .get();

    while (adGroupIterator.hasNext()) {
      var adGroup = adGroupIterator.next();
      adGroupCount++;

      var agStats = adGroup.getStatsFor('LAST_30_DAYS');
      var adGroupData = {
        id: adGroup.getId().toString(),
        campaignId: campaign.getId().toString(),
        campaignName: campaign.getName(),
        name: adGroup.getName(),
        status: adGroup.isEnabled() ? 'active' : 'paused',
        maxCpc: adGroup.bidding().getCpc() || 0,
        impressions: agStats.getImpressions(),
        clicks: agStats.getClicks(),
        cost: agStats.getCost(),
        conversions: agStats.getConversions(),
        ctr: agStats.getCtr()
      };
      data.adGroups.push(adGroupData);

      // Keywords
      var keywordIterator = adGroup.keywords()
        .withCondition('Status IN [ENABLED, PAUSED]')
        .get();

      while (keywordIterator.hasNext()) {
        var keyword = keywordIterator.next();
        keywordCount++;

        var kwStats = keyword.getStatsFor('LAST_30_DAYS');
        var keywordData = {
          id: keyword.getId().toString(),
          campaignId: campaign.getId().toString(),
          adGroupId: adGroup.getId().toString(),
          text: keyword.getText(),
          matchType: keyword.getMatchType(),
          status: keyword.isEnabled() ? 'active' : 'paused',
          qualityScore: keyword.getQualityScore() || 0,
          maxCpc: keyword.bidding().getCpc() || 0,
          impressions: kwStats.getImpressions(),
          clicks: kwStats.getClicks(),
          cost: kwStats.getCost(),
          conversions: kwStats.getConversions(),
          ctr: kwStats.getCtr()
        };
        data.keywords.push(keywordData);
      }

      // Ads (RSAs)
      var adIterator = adGroup.ads()
        .withCondition('Status IN [ENABLED, PAUSED]')
        .withCondition('Type = RESPONSIVE_SEARCH_AD')
        .get();

      while (adIterator.hasNext()) {
        var ad = adIterator.next();
        adCount++;

        var responsiveSearchAd = ad.asType().responsiveSearchAd();
        var headlines = [];
        var descriptions = [];

        // Collect headlines
        for (var i = 0; i < responsiveSearchAd.getHeadlines().length; i++) {
          headlines.push(responsiveSearchAd.getHeadlines()[i].text);
        }

        // Collect descriptions
        for (var i = 0; i < responsiveSearchAd.getDescriptions().length; i++) {
          descriptions.push(responsiveSearchAd.getDescriptions()[i].text);
        }

        var adStats = ad.getStatsFor('LAST_30_DAYS');
        var adData = {
          id: ad.getId().toString(),
          campaignId: campaign.getId().toString(),
          adGroupId: adGroup.getId().toString(),
          type: 'RESPONSIVE_SEARCH_AD',
          status: ad.isEnabled() ? 'active' : 'paused',
          headlines: headlines,
          descriptions: descriptions,
          path1: responsiveSearchAd.getPath1() || '',
          path2: responsiveSearchAd.getPath2() || '',
          finalUrl: ad.urls().getFinalUrl() || '',
          impressions: adStats.getImpressions(),
          clicks: adStats.getClicks(),
          cost: adStats.getCost(),
          conversions: adStats.getConversions(),
          ctr: adStats.getCtr()
        };
        data.ads.push(adData);
      }
    }
  }

  // Search Terms Report
  var searchTermReport = AdsApp.report(
    'SELECT Query, Clicks, Impressions, Cost, Conversions, CampaignName, AdGroupName ' +
    'FROM SEARCH_QUERY_PERFORMANCE_REPORT ' +
    'WHERE Impressions > 0 ' +
    'DURING LAST_30_DAYS'
  );

  var rows = searchTermReport.rows();
  while (rows.hasNext()) {
    var row = rows.next();
    data.searchTerms.push({
      query: row['Query'],
      campaignName: row['CampaignName'],
      adGroupName: row['AdGroupName'],
      clicks: parseInt(row['Clicks']),
      impressions: parseInt(row['Impressions']),
      cost: parseFloat(row['Cost']),
      conversions: parseFloat(row['Conversions'])
    });
  }

  // Summary
  data.summary = {
    totalCampaigns: campaignCount,
    totalAdGroups: adGroupCount,
    totalKeywords: keywordCount,
    totalAds: adCount,
    totalSearchTerms: data.searchTerms.length,
    collectedAt: data.timestamp
  };

  Logger.log('Collected: ' + campaignCount + ' campaigns, ' +
             adGroupCount + ' ad groups, ' +
             keywordCount + ' keywords, ' +
             adCount + ' ads, ' +
             data.searchTerms.length + ' search terms');

  return data;
}

/**
 * Sync data to Google Sheets
 */
function syncToSheets(data) {
  if (!CONFIG.spreadsheetId) {
    Logger.log('No spreadsheet ID configured, skipping Sheets sync');
    return;
  }

  try {
    var spreadsheet = SpreadsheetApp.openById(CONFIG.spreadsheetId);

    // Update summary sheet
    var summarySheet = getOrCreateSheet(spreadsheet, 'Summary');
    summarySheet.clear();
    summarySheet.appendRow(['Metric', 'Value']);
    summarySheet.appendRow(['Last Sync', data.timestamp]);
    summarySheet.appendRow(['Account', data.accountName]);
    summarySheet.appendRow(['Campaigns', data.summary.totalCampaigns]);
    summarySheet.appendRow(['Ad Groups', data.summary.totalAdGroups]);
    summarySheet.appendRow(['Keywords', data.summary.totalKeywords]);
    summarySheet.appendRow(['Ads', data.summary.totalAds]);
    summarySheet.appendRow(['Search Terms', data.summary.totalSearchTerms]);

    // Update campaigns sheet
    var campaignsSheet = getOrCreateSheet(spreadsheet, 'Campaigns');
    campaignsSheet.clear();
    campaignsSheet.appendRow(['Campaign ID', 'Name', 'Status', 'Budget', 'Impressions', 'Clicks', 'Cost', 'Conversions', 'CTR', 'Avg CPC']);
    data.campaigns.forEach(function(c) {
      campaignsSheet.appendRow([c.id, c.name, c.status, c.budget, c.impressions, c.clicks, c.cost, c.conversions, c.ctr, c.averageCpc]);
    });

    // Update keywords sheet (top 1000 to avoid quota issues)
    var keywordsSheet = getOrCreateSheet(spreadsheet, 'Keywords');
    keywordsSheet.clear();
    keywordsSheet.appendRow(['Keyword ID', 'Campaign', 'Ad Group', 'Text', 'Match Type', 'Status', 'QS', 'Max CPC', 'Impressions', 'Clicks', 'Cost', 'Conv', 'CTR']);
    data.keywords.slice(0, 1000).forEach(function(k) {
      var campaign = data.campaigns.find(function(c) { return c.id === k.campaignId; });
      var adGroup = data.adGroups.find(function(ag) { return ag.id === k.adGroupId; });
      keywordsSheet.appendRow([
        k.id,
        campaign ? campaign.name : '',
        adGroup ? adGroup.name : '',
        k.text,
        k.matchType,
        k.status,
        k.qualityScore,
        k.maxCpc,
        k.impressions,
        k.clicks,
        k.cost,
        k.conversions,
        k.ctr
      ]);
    });

    // Update search terms sheet (top 1000)
    var searchTermsSheet = getOrCreateSheet(spreadsheet, 'SearchTerms');
    searchTermsSheet.clear();
    searchTermsSheet.appendRow(['Query', 'Campaign', 'Ad Group', 'Impressions', 'Clicks', 'Cost', 'Conversions']);
    data.searchTerms.slice(0, 1000).forEach(function(st) {
      searchTermsSheet.appendRow([st.query, st.campaignName, st.adGroupName, st.impressions, st.clicks, st.cost, st.conversions]);
    });

    Logger.log('‚úì Synced to Google Sheets: ' + CONFIG.spreadsheetId);
  } catch (e) {
    Logger.log('‚ö† Sheets sync error: ' + e.message);
  }
}

function getOrCreateSheet(spreadsheet, sheetName) {
  var sheet = spreadsheet.getSheetByName(sheetName);
  if (!sheet) {
    sheet = spreadsheet.insertSheet(sheetName);
  }
  return sheet;
}

/**
 * Send data to backend API
 */
function sendToBackend(data) {
  if (!CONFIG.backendUrl) {
    Logger.log('No backend URL configured, skipping backend sync');
    return;
  }

  var url = CONFIG.backendUrl + '/api/script/sync';

  var payload = JSON.stringify(data);

  var options = {
    method: 'post',
    contentType: 'application/json',
    payload: payload,
    muteHttpExceptions: true
  };

  try {
    var response = UrlFetchApp.fetch(url, options);
    var responseCode = response.getResponseCode();

    if (responseCode === 200) {
      Logger.log('‚úì Backend sync successful');
      var result = JSON.parse(response.getContentText());
      Logger.log('Backend response: ' + JSON.stringify(result.summary));
    } else {
      Logger.log('‚ö† Backend sync failed: HTTP ' + responseCode);
      Logger.log('Response: ' + response.getContentText());
    }
  } catch (e) {
    Logger.log('‚ö† Backend sync error: ' + e.message);
  }
}

/**
 * Send error to backend
 */
function sendError(error) {
  if (!CONFIG.backendUrl) return;

  var url = CONFIG.backendUrl + '/api/script/error';

  var payload = JSON.stringify({
    accountId: CONFIG.accountId,
    timestamp: new Date().toISOString(),
    error: error.message,
    stack: error.stack
  });

  var options = {
    method: 'post',
    contentType: 'application/json',
    payload: payload,
    muteHttpExceptions: true
  };

  try {
    UrlFetchApp.fetch(url, options);
  } catch (e) {
    // Silent fail
  }
}
`;
}

/**
 * Save script configuration to database
 */
export function saveScriptConfig(db: Database, config: ScriptConfig): void {
  const stmt = db.prepare(`
    INSERT OR REPLACE INTO script_configs (account_id, spreadsheet_id, backend_url, created_at, updated_at)
    VALUES (?, ?, ?, datetime('now'), datetime('now'))
  `);

  stmt.run(config.accountId, config.spreadsheetId, config.backendUrl);
}

/**
 * Get script configuration from database
 */
export function getScriptConfig(db: Database, accountId: string): ScriptConfig | null {
  const stmt = db.prepare(`
    SELECT account_id, spreadsheet_id, backend_url
    FROM script_configs
    WHERE account_id = ?
  `);

  const row = stmt.get(accountId) as any;

  if (!row) return null;

  return {
    accountId: row.account_id,
    spreadsheetId: row.spreadsheet_id,
    backendUrl: row.backend_url
  };
}

/**
 * Get script status (last sync time, health)
 */
export function getScriptStatus(db: Database, accountId: string): {
  isActive: boolean;
  lastSync: string | null;
  lastError: string | null;
  dataSummary: any;
} {
  const syncStmt = db.prepare(`
    SELECT timestamp, summary
    FROM script_syncs
    WHERE account_id = ?
    ORDER BY timestamp DESC
    LIMIT 1
  `);

  const lastSync = syncStmt.get(accountId) as any;

  const errorStmt = db.prepare(`
    SELECT timestamp, error
    FROM script_errors
    WHERE account_id = ?
    ORDER BY timestamp DESC
    LIMIT 1
  `);

  const lastError = errorStmt.get(accountId) as any;

  // Check if script is active (synced in last 2 hours)
  let isActive = false;
  if (lastSync) {
    const lastSyncTime = new Date(lastSync.timestamp);
    const now = new Date();
    const hoursSinceSync = (now.getTime() - lastSyncTime.getTime()) / (1000 * 60 * 60);
    isActive = hoursSinceSync < 2;
  }

  return {
    isActive,
    lastSync: lastSync ? lastSync.timestamp : null,
    lastError: lastError ? lastError.error : null,
    dataSummary: lastSync ? JSON.parse(lastSync.summary) : null
  };
}
